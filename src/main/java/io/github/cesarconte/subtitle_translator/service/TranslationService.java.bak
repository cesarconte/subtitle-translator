package io.github.cesarconte.subtitle_translator.service;

import io.github.cesarconte.subtitle_translator.model.SubtitleBlock;
import io.github.cesarconte.subtitle_translator.model.LanguageDetectionResponse;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.RestTemplate;
import com.optimaize.langdetect.LanguageDetector;
import com.optimaize.langdetect.LanguageDetectorBuilder;
import com.optimaize.langdetect.ngram.NgramExtractors;
import com.optimaize.langdetect.profiles.LanguageProfile;
import com.optimaize.langdetect.profiles.LanguageProfileReader;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional;

/**
 * Service to perform translations using the DeepL API
 */
@Service
public class TranslationService {

    private final RestTemplate restTemplate;

    @Value("${deepl.api.key}")
    private String apiKey;

    @Value("${deepl.api.url:https://api-free.deepl.com/v2}")
    private String apiUrl;

    private static final String SUBTITLE_SEPARATOR = "<SUBT_DIV>";
    private static final int GROUP_SIZE = 5; // Reduced group size for better structure preservation
    private List<SubtitleBlock> subtitles; // References to all subtitles for processing

    private static LanguageDetector languageDetector;
    private static List<LanguageProfile> languageProfiles;

    static {
        try {
            languageProfiles = new LanguageProfileReader().readAllBuiltIn();
            languageDetector = LanguageDetectorBuilder.create(NgramExtractors.standard())
                    .withProfiles(languageProfiles)
                    .build();
        } catch (Exception e) {
            throw new RuntimeException("Failed to initialize language detector", e);
        }
    }

    public TranslationService() {
        this.restTemplate = new RestTemplate();
    }
    
    // Log API key when Spring initializes this bean (called after properties are set)
    @jakarta.annotation.PostConstruct
    private void init() {
        // Log para mostrar qué API key se está usando (parcialmente oculta por seguridad)
        if (apiKey != null && apiKey.length() > 8) {
            String firstFour = apiKey.substring(0, 4);
            String lastFour = apiKey.substring(apiKey.length() - 4);
            System.out.println("Usando DeepL API key: " + firstFour + "..." + lastFour);
        } else {
            System.out.println("¡ADVERTENCIA! API key de DeepL no encontrada o inválida");
        }
    }

    /**
     * Translates text using the DeepL API
     *
     * @param text       Text to translate
     * @param targetLang Target language code
     * @param sourceLang Source language code (null for automatic detection)
     * @return Translated text
     */
    public String translateText(String text, String targetLang, String sourceLang) {
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);
        headers.set("Authorization", "DeepL-Auth-Key " + apiKey);

        MultiValueMap<String, String> formData = new LinkedMultiValueMap<>();
        formData.add("text", text);
        formData.add("target_lang", targetLang);

        if (sourceLang != null && !sourceLang.equals("auto")) {
            formData.add("source_lang", sourceLang);
        }

        HttpEntity<MultiValueMap<String, String>> request = new HttpEntity<>(formData, headers);

        String url = apiUrl + "/translate";
        // Using raw type with suppressed warnings
        @SuppressWarnings("rawtypes")
        ResponseEntity<Map> response = restTemplate.postForEntity(url, request, Map.class);

        if (!response.getStatusCode().is2xxSuccessful()) {
            throw new RuntimeException("Error from DeepL API: " + response.getStatusCode());
        }

        @SuppressWarnings("unchecked")
        Map<String, Object> responseBody = (Map<String, Object>) response.getBody();
        if (responseBody == null) {
            throw new RuntimeException("Empty response from DeepL server");
        }

        @SuppressWarnings("unchecked")
        List<Map<String, Object>> translations = (List<Map<String, Object>>) responseBody.get("translations");

        if (translations == null || translations.isEmpty()) {
            throw new RuntimeException("No translations received");
        }

        return (String) translations.get(0).get("text");
    }

    /**
     * Translates a list of subtitle blocks with progress tracking
     *
     * @param subtitles       List of subtitle blocks
     * @param targetLang      Target language code
     * @param sourceLang      Source language code (can be "auto" for automatic
     *                        detection)
     * @param sessionId       Session ID for progress tracking
     * @param progressService Progress tracking service
     * @return List of translated subtitle blocks with confidence scores
     */
    public List<SubtitleBlock> translateSubtitlesWithProgress(
            List<SubtitleBlock> subtitles,
            String targetLang,
            String sourceLang,
            String sessionId,
            ProgressTrackingService progressService) {
        // Store reference to all subtitles for the new translation approach
        this.subtitles = subtitles;

        // Calculate total characters for progress tracking
        int totalChars = 0;
        for (SubtitleBlock subtitle : subtitles) {
            String text = String.join("\n", subtitle.getText());
            totalChars += text.length();
        }

        // Update progress tracking with total characters
        progressService.setTotalChars(sessionId, totalChars);
        progressService.updateProgress(sessionId, "preparing",
                "Preparing content for translation...", 0);

        // Save original texts to calculate confidence later
        List<String> originalTexts = new ArrayList<>();
        for (SubtitleBlock subtitle : subtitles) {
            originalTexts.add(String.join("\n", subtitle.getText()));
        }

        // Group subtitles to minimize API calls
        List<List<SubtitleBlock>> groups = new ArrayList<>();
        for (int i = 0; i < subtitles.size(); i += GROUP_SIZE) {
            groups.add(subtitles.subList(
                    i,
                    Math.min(i + GROUP_SIZE, subtitles.size())));
        }

        // Translate using our improved approach that preserves structure
        List<SubtitleBlock> translatedSubtitles = new ArrayList<>();
        int translatedChars = 0;
        int groupIndex = 0;

        for (List<SubtitleBlock> group : groups) {
            // Update progress tracker
            int groupTotalChars = 0;
            for (SubtitleBlock subtitle : group) {
                groupTotalChars += String.join("\n", subtitle.getText()).length();
            }

            progressService.updateProgress(sessionId, "translating",
                    String.format("Translating block %d of %d...", groupIndex + 1, groups.size()),
                    translatedChars);

            // Prepare text with special markers for structure preservation
            StringBuilder textWithMarkers = new StringBuilder();

            for (int i = 0; i < group.size(); i++) {
                SubtitleBlock subtitle = group.get(i);

                // Add subtitle identifier marker with ID
                textWithMarkers.append("<SUBT:").append(subtitle.getId()).append(">\n");

                // Add lines with markers to identify each line position
                String[] lines = subtitle.getText();
                for (int lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                    textWithMarkers.append("<LINE:").append(lineIndex + 1).append(">")
                            .append(lines[lineIndex])
                            .append("</LINE:").append(lineIndex + 1).append(">\n");
                }

                // Close subtitle marker
                textWithMarkers.append("</SUBT:").append(subtitle.getId()).append(">");

                // Add separator between subtitles, except the last one
                if (i < group.size() - 1) {
                    textWithMarkers.append("\n").append(SUBTITLE_SEPARATOR).append("\n");
                }
            }

            // Translate the marked text
            String translatedMarkedText = translateText(textWithMarkers.toString(), targetLang, sourceLang);
            try {
                Thread.sleep(1000);  // Añadimos pausa para evitar error 429
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            
            // Process the translated text and extract subtitles while preserving structure
            processTranslatedMarkedText(translatedMarkedText, group, translatedSubtitles, originalTexts);

            // Update translated character count for progress
            translatedChars += groupTotalChars;
            groupIndex++;
        }

        // Sort subtitles by ID to maintain original order
        translatedSubtitles.sort((a, b) -> Integer.compare(a.getId(), b.getId()));

        // Final progress update
        progressService.updateProgress(sessionId, "finalizing", "Finalizing translation...", totalChars);

        return translatedSubtitles;
    }

    /**
     * Translates a list of subtitle blocks
     *
     * @param subtitles  List of subtitle blocks
     * @param targetLang Target language code
     * @param sourceLang Source language code (can be "auto" for automatic
     *                   detection)
     * @return List of translated subtitle blocks with confidence scores
     */
    public List<SubtitleBlock> translateSubtitles(List<SubtitleBlock> subtitles, String targetLang, String sourceLang) {
        // Mejorado: Preservar mejor la estructura del texto usando marcadores
        // especiales para cada línea

        // Group subtitles to minimize API calls
        List<List<SubtitleBlock>> groups = new ArrayList<>();
        for (int i = 0; i < subtitles.size(); i += GROUP_SIZE) {
            groups.add(subtitles.subList(
                    i,
                    Math.min(i + GROUP_SIZE, subtitles.size())));
        }

        // Save original texts to calculate confidence later
        List<String> originalTexts = new ArrayList<>();
        for (SubtitleBlock subtitle : subtitles) {
            originalTexts.add(String.join("\n", subtitle.getText()));
        }

        // Translate each group with structure preservation
        List<SubtitleBlock> translatedSubtitles = new ArrayList<>();

        for (List<SubtitleBlock> group : groups) {
            // Prepare text with special markers for structure preservation
            StringBuilder textWithMarkers = new StringBuilder();

            for (int i = 0; i < group.size(); i++) {
                SubtitleBlock subtitle = group.get(i);

                // Add subtitle identifier marker with ID
                textWithMarkers.append("<SUBT:").append(subtitle.getId()).append(">\n");

                // Add lines with markers to identify each line position
                String[] lines = subtitle.getText();
                for (int lineIndex = 0; lineIndex < lines.length; lineIndex++) {
                    textWithMarkers.append("<LINE:").append(lineIndex + 1).append(">")
                            .append(lines[lineIndex])
                            .append("</LINE:").append(lineIndex + 1).append(">\n");
                }

                // Close subtitle marker
                textWithMarkers.append("</SUBT:").append(subtitle.getId()).append(">");

                // Add separator between subtitles, except the last one
                if (i < group.size() - 1) {
                    textWithMarkers.append("\n").append(SUBTITLE_SEPARATOR).append("\n");
                }
            }

            // Translate the marked text
            String translatedMarkedText = translateText(textWithMarkers.toString(), targetLang, sourceLang);
            try {
                Thread.sleep(1000);  // Añadimos pausa para evitar error 429
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            
            // Process the translated text and extract subtitles while preserving structure
            processTranslatedMarkedText(translatedMarkedText, group, translatedSubtitles, originalTexts);
        }

        // Sort subtitles by ID to maintain original order
        translatedSubtitles.sort((a, b) -> Integer.compare(a.getId(), b.getId()));

        return translatedSubtitles;
    }

    /**
     * Process translated text with markers and extract structured subtitles
     *
     * @param translatedText      The translated text with structure markers
     * @param originalGroup       The original subtitle blocks for reference
     * @param translatedSubtitles List to add the translated subtitles to
     * @param originalTexts       List of original texts for confidence calculation
     */
    private void processTranslatedMarkedText(String translatedText, List<SubtitleBlock> originalGroup,
            List<SubtitleBlock> translatedSubtitles, List<String> originalTexts) {
        // Separate by subtitle markers
        String[] subtitleBlocks = translatedText.split(SUBTITLE_SEPARATOR);

        for (String block : subtitleBlocks) {
            // Extract subtitle ID
            java.util.regex.Pattern idPattern = java.util.regex.Pattern.compile("<SUBT:(\\d+)>");
            java.util.regex.Matcher idMatcher = idPattern.matcher(block);

            if (idMatcher.find()) {
                int id = Integer.parseInt(idMatcher.group(1));

                // Find original subtitle for this ID
                SubtitleBlock originalSubtitle = originalGroup.stream()
                        .filter(s -> s.getId() == id)
                        .findFirst()
                        .orElse(null);

                if (originalSubtitle != null) {
                    // Extract lines with markers
                    java.util.regex.Pattern linePattern = java.util.regex.Pattern
                            .compile("<LINE:\\d+>(.*?)</LINE:\\d+>");
                    java.util.regex.Matcher lineMatcher = linePattern.matcher(block);

                    List<String> translatedLines = new ArrayList<>();
                    while (lineMatcher.find()) {
                        translatedLines.add(lineMatcher.group(1).trim());
                    }

                    // If no lines were found with markers, extract text between SUBT tags
                    if (translatedLines.isEmpty()) {
                        String extractedText = block.replaceAll("<SUBT:\\d+>\\s*", "")
                                .replaceAll("\\s*</SUBT:\\d+>", "")
                                .trim();

                        if (!extractedText.isEmpty()) {
                            translatedLines = List.of(extractedText.split("\n"));
                        } else {
                            // Fallback to original structure but with empty text
                            translatedLines = new ArrayList<>();
                            for (int i = 0; i < originalSubtitle.getText().length; i++) {
                                translatedLines.add("");
                            }
                        }
                    }

                    // Convert list to array
                    String[] translatedLineArray = translatedLines.toArray(new String[0]);

                    // Find the original text for confidence calculation
                    int originalIndex = -1;
                    for (int i = 0; i < subtitles.size(); i++) {
                        if (subtitles.get(i).getId() == id) {
                            originalIndex = i;
                            break;
                        }
                    }

                    String originalText = originalIndex >= 0 ? originalTexts.get(originalIndex)
                            : String.join("\n", originalSubtitle.getText());
                    String joinedTranslatedText = String.join("\n", translatedLines);

                    // Calculate confidence
                    double confidenceScore = ConfidenceCalculator.calculateConfidence(originalText,
                            joinedTranslatedText);

                    // Create translated subtitle block with original time code
                    SubtitleBlock translatedSubtitle = new SubtitleBlock(
                            id,
                            originalSubtitle.getTimeCode(),
                            translatedLineArray,
                            confidenceScore);

                    translatedSubtitles.add(translatedSubtitle);
                }
            }
        }
    }

    /**
     * Detects the language of the given SRT content
     * 
     * @param srtContent SRT file content
     * @return LanguageDetectionResponse with detected language and confidence
     */
    public LanguageDetectionResponse detectLanguage(String srtContent) {
        // Remove SRT timecodes and numbers, keep only text
        String text = srtContent.replaceAll("(?m)^\\d+$", "")
                .replaceAll("(?m)^\\d{2}:\\d{2}:\\d{2},\\d{3} --> \\d{2}:\\d{2}:\\d{2},\\d{3}$", "")
                .replaceAll("[\r\n]+", " ").trim();
        Optional<com.optimaize.langdetect.DetectedLanguage> best = languageDetector.getProbabilities(text).stream()
                .findFirst();
        if (best.isPresent()) {
            com.optimaize.langdetect.DetectedLanguage detected = best.get();
            String lang = detected.getLocale().getLanguage();
            double confidence = detected.getProbability();
            return new LanguageDetectionResponse(true, lang, confidence);
        } else {
            return new LanguageDetectionResponse(false, "Could not detect language");
        }
    }
}
